[{"content":"","date":null,"permalink":"/blog/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"/blog/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"Hello!\nWelcome to my personal site! Here I will be posting my projects and things I\u0026rsquo;m learning.\nI\u0026rsquo;ve recently rewritten this site in hugo! I appreciate how blazingly fast and customizable it is.\n","date":"July 24, 2024","permalink":"/blog/posts/hello/","section":"Posts","summary":"Hello!","title":"Hello Hugo"},{"content":" Tech Stack # Component Tech Platforms iOS, iPadOS Architecture TCA (The Composable Architecture) UI SwiftUI Purchases RevenueCat ","date":"June 1, 2024","permalink":"/blog/projects/aesthetext/","section":"Projects","summary":" Tech Stack # Component Tech Platforms iOS, iPadOS Architecture TCA (The Composable Architecture) UI SwiftUI Purchases RevenueCat ","title":"AestheText"},{"content":"These are many projects that I have worked on.\n","date":null,"permalink":"/blog/projects/","section":"Projects","summary":"These are many projects that I have worked on.","title":"Projects"},{"content":"In our last article, we learned about how the generics system is deeply integrated into Swift at practically every level. This can give us magical features that help like Type Inference which makes our code easier to read and right, but it can also lead frustrating and confusing compile-time errors. Furthermore, most modern Swift libraries are filled with generic code, especially in Apple first-party frameworks such as SwiftUI, Combine, and the recently announced SwiftData. I hope that I\u0026rsquo;ve made a strong case that generics in Swift are simply too important to ignore. So without further ado, let\u0026rsquo;s dive into generics, albeit with a slightly different approach than you might expect.\nReading Generic Code #You might expect an article on Swift Generics to start with writing generic code, and in fact [[#Suggested Articles on Swift Generics|many fantastic authors have already covered this quite well]]. But perhaps a better approach would be to start with reading generic code. This is for a few reasons:\nBy nature, generic code is generalized to multiple use cases. It takes work to understand one use case, let alone many. Generic code is quite abstract. So here is what we will do. Let\u0026rsquo;s look at a few basic common types that are used throughout SwiftUI, and see what we can learn from them, starting with the most basic of them all, the humble View.\nSwiftUI\u0026rsquo;s View #Every single SwiftUI View has a : View after it\u0026rsquo;s name like so:\nstruct MyView: View { var body: some View { Text(\u0026#34;Hello World\u0026#34;) } } In Xcode, right click on the word View and click \u0026ldquo;Jump to Definition\u0026rdquo;. You should see something like this:\npublic protocol View { /// ... associatedtype Body : View /// ... @ViewBuilder @MainActor var body: Self.Body { get } } What can we learn here about the View type? Well, that\u0026rsquo;s a bit of a trick question. View isn\u0026rsquo;t really a Type, exactly. It\u0026rsquo;s a protocol. The Swift documentation says this:\nProtocols as Types #Protocols don‚Äôt actually implement any functionality themselves. Regardless, you can use a protocol as a type in your code.\nThink of protocols as rules. In real life, if we follow certain rules, we get perks. If you pass the driving test, then you get the perk of being allowed to drive legally. Likewise, if your type conforms to the View protocol, then it now gets to do all the cool things that SwiftUI Views can do. But the View protocol doesn\u0026rsquo;t actually do anything since it doesn\u0026rsquo;t \u0026ldquo;actually implement any functionality\u0026rdquo;. The Type that conforms to the View protocol is the actual thing that has properties and methods.\nIntroducing Concrete and \u0026ldquo;Soft\u0026rdquo; Types #If you look at the Swift docs on Types and do a CMD-F search for \u0026ldquo;concrete type\u0026rdquo;, you\u0026rsquo;ll see that the phrase is used throughout. Unfortunately, though, I haven\u0026rsquo;t yet found an official definition of what exactly concrete type means.1 But I think the definition is pretty clear from the context. A concrete type is the actual type that will be used at runtime. But if there\u0026rsquo;s such a thing as concrete types then that implies that there are non-concrete types, types that aren\u0026rsquo;t actually used at runtime. However, I haven\u0026rsquo;t found an official name for these non-concrete types, so I\u0026rsquo;ll refer to them as soft types. A soft type is a type isn\u0026rsquo;t actually used at runtime. Instead, it gives instructions to Swift on how to find the concrete type. We can see an example of this in every SwiftUI View:\nvar body: some View The body property is explicitly typed using : but what is the type? some View. But View is not a concrete type since it\u0026rsquo;s a protocol. Somewhere, Swift has to infer the concrete type. Remember, Swift is a strongly typed language so everything has a type. The answer is that this is an example of an opaque type. Essentially, we\u0026rsquo;re telling Swift that body will be \u0026ldquo;some View\u0026rdquo;. We\u0026rsquo;re not telling Swift which specific type it will be. Instead, Swift will infer the type for us as long as we give it a type that conforms to View. For example:\nvar body: some View { // `some View` is the soft type Text(\u0026#34;Hello World\u0026#34;) // `Text` is the concrete type } // ... var body: some View { VStack { // `some View` is the soft type Text(\u0026#34;Hello World\u0026#34;) } // The concrete type is `VStack\u0026lt;Text\u0026gt;` } As you can see VStack is generic. Now try altering your body to look like this:\nstruct MyView: View { var body: VStack { // üõë Error: Reference to generic type \u0026#39;VStack\u0026#39; requires arguments in \u0026lt;...\u0026gt; VStack { // `some View` is the soft type Text(\u0026#34;Hello World\u0026#34;) } // The concrete type is `VStack\u0026lt;Text\u0026gt;` } } So I would say that VStack is also a soft type. In other words, even if Swift knows that it\u0026rsquo;s a VStack, that is not enough information for Swift to infer the concrete type. In fact, every generic type is a soft type. Every time that we use a generic type, we have to make sure that we are giving Swift enough information to find the concrete type. This could get very tedious and error prone, and so that\u0026rsquo;s why Swift gives us various tools like opaque types (the some keyword) to make this easier.\nstruct MyView: View { var body: some View { // `some View` is the soft type List { // ‚≠ê the concrete type is some gigantic nested monstrosity ForEach(0..\u0026lt;9) { num in VStack { Text(\u0026#34;This is some text in a row cell.\u0026#34;) Text(\u0026#34;This is the current number: \\(num)\u0026#34;) } } .onAppear { print(\u0026#34;The type of MyView.body is \\(type(of: self.body))\u0026#34;) } } } } associatedType: generics for protocols #Just as we can make types generic, we can also make protocols generic using the associatedType keyword. The Swift docs says:\nWhen defining a protocol, it‚Äôs sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An¬†associated type¬†gives a placeholder name to a type that‚Äôs used as part of the protocol. The actual type to use for that associated type isn‚Äôt specified until the protocol is adopted.\nSo just like how the Array type has a generic type parameter called Element, the View protocol has an associated type called Content. And as we can see in the definition, Body must conform to the View protocol.\npublic protocol View { associatedtype Body : View @ViewBuilder @MainActor var body: Self.Body { get } } But don\u0026rsquo;t forget Body is not a concrete type. It\u0026rsquo;s a soft type, a placeholder for a type that conforms to View. This means that every time you use a protocol with an associatedtype, you must tell the compiler what the associatedtype is. So in the example below how are we telling Swift the type for body?\nstruct MyView: View { var body: some View { List { Text(\u0026#34;Hello\u0026#34;) } } } When we used the : we declared the type for body explicitly right? Well, no. Remember that the some keyword is also a placeholder, a soft type. No, the concrete type is actually List\u0026lt;Text\u0026gt; in this case, and so the associatedtype Body was implicitly[^2] evaluated to be List\u0026lt;Text\u0026gt;.\nHow to explicitly declare the associatedtype #If you recall, earlier we learned how to explicitly and implicitly declare generic types:\nlet implicitArray = [\u0026#34;strings\u0026#34;] let explicitArray: Array\u0026lt;String\u0026gt; = [\u0026#34;more strings\u0026#34;] But did you know you can even do this for associatedtypes?\nstruct MyView: View { typealias Body = Text // explicitly set the associatedtype var body: Text { Text(\u0026#34;Hello\u0026#34;) } } In practice, this wouldn\u0026rsquo;t be the most practical way to do this, in this situation2, but there are some situations when it can be helpful. In fact this is often what Xcode will automatically do if you click a \u0026ldquo;Fix Me\u0026rdquo; button.\nIf you write this:\nstruct MyView: View { // üî¥ type \u0026#39;MyView\u0026#39; does not conform to protocol \u0026#39;View\u0026#39; // this is intentionally blank } \u0026hellip; and then click the \u0026ldquo;Fix Me\u0026rdquo; button in the error, then Xcode will add this:\nstruct MyView: View { // üî¥ type \u0026#39;MyView\u0026#39; does not conform to protocol \u0026#39;View\u0026#39; typealias Body = } This is because, Xcode doesn\u0026rsquo;t have all the information it needs to help you fulfill the protocol requirement yet. It doesn\u0026rsquo;t know what type Body is. Now fill in Body\u0026hellip;:\nstruct MyView: View { // üî¥ type \u0026#39;MyView\u0026#39; does not conform to protocol \u0026#39;View\u0026#39; typealias Body = Text } and click \u0026ldquo;Fix Me\u0026rdquo; one more time and Xcode will add this\u0026hellip;\u0026quot;\nstruct MyView: View { // üî¥ type \u0026#39;MyView\u0026#39; does not conform to protocol \u0026#39;View\u0026#39; typealias Body = Text var body: Text } Why not just explicitly type everything? #Perhaps you are thinking, \u0026ldquo;Why can\u0026rsquo;t I just explicitly type everything? Why do we need concrete and so-called soft-types?\u0026rdquo; In other words, why do we need type inference.\nThere are a few reasons why type inference is powerful. As we established earlier, Swift\u0026rsquo;s strongly typed system allows the compiler to guarantee that your code is safe and that certain bugs are impossible to write! üéâ In addition, it allows the compiler to make some optimizations behind the scenes that make our code more performant, and we get all these benefits for free!\nBut a strongly typed system is also more strict and cumbersome to use. It also requires more maintenance as our codebase evolves over time. For this reason, the Swift team decided to adopt a philosophy of design called [[Progressive Disclosure of Information]]. In other words, Swift will hide complexity until it is actually relevant and helpful, and one of the ways that they achieved this was through generics. Through type inference, the Swift compiler is empowered to handle a lot of the grunt work for us, and we can focus on only the things that we care about. For example, we don\u0026rsquo;t need to explicitly tell Swift what the concrete type of Body is. But it is also nice to know that we have the power to be explicit, should the need arise.\nConclusion #In this article we learned about concrete types, and so-called soft types. We also learned how they can be used explicitly and implicitly. Once again, we\u0026rsquo;ve learned how the Swift compiler has your back and can prevent you from writing certain types of bugs. Furthermore, while the type system can produce some confusing error messages, that can feel very unhelpful, Swift become much more helpful when you \u0026ldquo;have a conversation with it\u0026rdquo;. This can be done by explicitly setting types in order to see what errors are produced.\nYou might say that I haven\u0026rsquo;t found a concrete definition of concrete types.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nbecause we would have to remember to keep the types of Body and body in sync with each other.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"April 1, 2024","permalink":"/blog/swift-generics/concrete-types-swift/","section":"Posts","summary":"In our last article, we learned about how the generics system is deeply integrated into Swift at practically every level.","title":"Concrete and \"Soft\" Types in Swift"},{"content":"","date":null,"permalink":"/blog/topics/generics/","section":"Topics","summary":"","title":"Generics"},{"content":"","date":null,"permalink":"/blog/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":null,"permalink":"/blog/topics/swift/","section":"Topics","summary":"","title":"Swift"},{"content":"","date":null,"permalink":"/blog/series/swift-generics-demystified/","section":"Series","summary":"","title":"Swift Generics Demystified"},{"content":"","date":null,"permalink":"/blog/topics/","section":"Topics","summary":"","title":"Topics"},{"content":"Generics are one of the most powerful features in Swift, yet they can often feel overwhelming, even for seasoned Swift developers. In this series we\u0026rsquo;ll learn how to make generics simple, useful, and even fun!\nBack to Basics #But to start off, we\u0026rsquo;ll look somewhere you probably won\u0026rsquo;t expect: declaring variables.\nlet strings = [\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;] let oneLongString = strings.joined(separator: \u0026#34;, \u0026#34;) This seemingly simple piece of code has some hidden functionality. Consider for a second, what type is strings. That\u0026rsquo;s easy. It\u0026rsquo;s an Array. But that answer is only half correct. Furthermore, how does strings know about the joined method? How does it know how to join the elements? What if there was a number in that Array. How would it join a String and an Int for example? Here, most Swift developers would say that the answer is Type Inference. And while that answer is technically correct, it\u0026rsquo;s still missing part of the story.\nThe problem with simply saying that it\u0026rsquo;s Type Inference is that it feels like magic, and while Swift certainly feels magical, it most certainly is not magical (and that\u0026rsquo;s actually a good thing). Magic, may produce joy, surprise, and wonder but it is also mysterious, unpredictable, and impossible to understand. So, how did Swift infer the type for the strings variable? Was it just really smart? No, absolutely not. The first step to understanding Swift, the Swift type system, and Swift generics is learning this lesson:\nSwift is not magic, even when it feels like it is. Every single thing it does has a predictable reason.\nSorry to wax philosophical on you, but the sooner that we learn this lesson, the sooner generics will make sense to us. So, finally, let\u0026rsquo;s answer the question. How does Swift know that strings is an Array. The answer is: you said that it was! Swift found the type from the value, and assigned that same type to the variable.\n[\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;] // this is an `Array` Literal. // by assigning an Array literal to `strings`, Swift has \u0026#34;inferred\u0026#34; that // strings must be an Array. let strings: Array = [\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;] // it\u0026#39;s as if you üëÜüèº actually declared the type right here Explicit vs. Implicit types #Try it for yourself. Declare an Array like so:\nlet strings = [\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;] and then afterwards, declare the type explicitly like this:\nlet strings: Array = [\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;] // notice how there\u0026#39;s no error Now, let\u0026rsquo;s see what happens if we use a different type.\nlet strings: Dictionary = [\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;] // Error: Dictionary of type \u0026#39;Dictionary\u0026#39; cannot be initialized with array literal Why did we get an error? Because we gave Swift two conflicting instructions. We said that strings is a Dictionary but we didn\u0026rsquo;t give it a Dictionary, we gave it an Array literal, which is an Array. So, which one is it? Is strings an Array or a Dictionary? The answer is Dictionary. Notice how the error says Dictionary of type 'Dictionary' cannot be initialized with array literal and it doesn\u0026rsquo;t say something like Array cannot be type casted into Dictionary.\nThe point is that this line has not one but 2 type declarations (explicit on the left, and implicit on the right) and they have to agree with each other. No exceptions. So remember this principle:\nSwift is a very strongly typed language. In other words, it won\u0026rsquo;t allow you to break the rules. Learn how to follow the rules, or your code simply won\u0026rsquo;t compile.\nOr a better way of thinking of it is: \u0026ldquo;Swift\u0026rsquo;s got your back and will protect you from making silly mistakes\u0026rdquo;.\nGeneric Types #But we still haven\u0026rsquo;t answered one question, how does strings know what the joined method is? Is it just a method on Array? Nope.\nlet strings = [\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;] let oneLongString = strings.joined(separator: \u0026#34;, \u0026#34;) // no Error let numbers: Array = [3, 4, 5] let maybeOneLongNumber = numbers.joined(separator: \u0026#34;, \u0026#34;) // Error: No exact matches in call to instance method \u0026#39;joined\u0026#39; This is because strings and numbers are not the same type even though they are both Arrays. strings is type Array\u0026lt;String\u0026gt; and numbers is type Array\u0026lt;Int\u0026gt;. See those \u0026lt;angle brackets\u0026gt;? Those are generics. This is because Array is a generic type. Let\u0026rsquo;s look at the definition of Array:\n@frozen public struct Array\u0026lt;Element\u0026gt; { // ... } What\u0026rsquo;s Element? It\u0026rsquo;s a type parameter. It\u0026rsquo;s kind of like Swift is saying \u0026ldquo;I have this type called Array that can hold some other type (let\u0026rsquo;s call it Element), but you, the programmer, get to decide which type Element will be\u0026rdquo;. This is why, for some, it might be unhelpful to call this type inference. Type inference seems to imply that Swift just sort of \u0026ldquo;figured out\u0026rdquo; what the type is. But that really isn\u0026rsquo;t what happened. Swift didn\u0026rsquo;t \u0026ldquo;figure it out\u0026rdquo;, you told Swift what the type was (either explicitly or implicitly).\nlet strings = [\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;] // implicit type declaration of Array\u0026lt;String\u0026gt; let numbers: Array\u0026lt;Int\u0026gt; = [3, 4, 5] // explicit type declaration Tip: [String] is syntactic sugar for Array\u0026lt;String\u0026gt;. Note that Array is special in that it has two ways to explicitly declare its type. [String] and Array\u0026lt;String\u0026gt; which both mean the same thing.\nThe moral of the story is:\nSwift Generics are everywhere in Swift. If you don\u0026rsquo;t understand generics, then you won\u0026rsquo;t understand Swift.\nThink of Swift as your pair programmer #Finally, let\u0026rsquo;s leave you with something that is actually useful for you. SwiftUI often feels magical until you get hit with one of these kinds of errors.\nstruct Contact: Identifiable { let id: UUID var name: String } struct BottomBarView: View { @State private var contacts = [] var body: some View { NavigationStack { List { ForEach(self.$contacts) { contact in // üëÜüèº üõë Cannot convert value of type \u0026#39;Binding\u0026lt;[Any]\u0026gt;\u0026#39; to expected argument type \u0026#39;Range\u0026lt;Int\u0026gt;\u0026#39; TextField(\u0026#34;Name\u0026#34;, text: contact.name) // üëÜüèº üõë Value of type \u0026#39;Int\u0026#39; has no member \u0026#39;name\u0026#39; } } .navigationTitle(\u0026#34;Contacts\u0026#34;) } } } Why does Swift think that name is an Int. And why is ForEach expecting a Range\u0026lt;Int\u0026gt;? Moments like this can be extremely frustrating. Worse, yet, they are very difficult to search for an answer since you\u0026rsquo;re error message is likely to be too specific to your code. Even worse still, there is no way to debug this problem since our code isn\u0026rsquo;t even compiling. Moments like this can make us want to scream at the compiler, but instead why don\u0026rsquo;t we try having a conversation with it.\nNotice how the first message Cannot convert value of type 'Binding\u0026lt;[Any]\u0026gt;' to expected argument type 'Range\u0026lt;Int\u0026gt;' starts with Cannot convert value? In my experience, this almost always means that there is some sort of type mismatch. In other words, the type that I think I\u0026rsquo;m using and the type that the compiler determines I\u0026rsquo;m using are actually different types.\nUs: Hey Swift, what is the type?\nWhat is the type of self.$contacts? Isn\u0026rsquo;t it Array? Swift already knows that it\u0026rsquo;s an Array because I assigned an Array literal ([]). But don\u0026rsquo;t forget, Array is a generic type. This means that it\u0026rsquo;s actually not complete to say that it\u0026rsquo;s an Array. Let\u0026rsquo;s ask the compiler \u0026ldquo;What kind of Array is it?\u0026rdquo; Right-click the contacts variable after @State private var and choose \u0026ldquo;Show Quick Help\u0026rdquo;. Hopefully, if Xcode doesn\u0026rsquo;t fail1, it should show the following:\n@State var contacts: [Any] { get nonmutating set } Swift: It\u0026rsquo;s an [Any].\nAs you can see contacts is not a [Contact] but instead a [Any]. You might say that Swift inferred the wrong type but that\u0026rsquo;s not very helpful. I think it\u0026rsquo;s more accurate to say that we did not give Swift enough information.\nUs: Actually Swift, could you make sure that is a [Contact], please.\n@State private var contacts: [Contact] = [] And voila all of the errors should be gone now! Before, we didn\u0026rsquo;t give Swift enough information to know what type contacts was, so Swift essentially had to guess. Swift guessed [Any] and this produced a whole host of problems. For example, ForEach creates a view for each element in our contacts array, and we named that element contact. But because contacts was [Any] that means contact was Any, and this produced the error. Any has no parameter name.\nBut afterwards we explicitly said that the type is [Contact]. Now, that Swift has more information, it can tell that contact is a Contact and therefore has a name property.\nTakeaways #Ask yourself \u0026ldquo;What type does Swift think this variable is and is that the same type I\u0026rsquo;m expecting.\u0026rdquo;\nIf your code won\u0026rsquo;t compile, the reason why is often going to be because of an incorrect type somewhere in your code. Try explicitly typing variables to see what will happen. Many times, this will give Swift just the amount of info that it needs. Other times, you might discover that the type wasn\u0026rsquo;t what you assumed it was. This doesn\u0026rsquo;t mean that you should explicitly type everything, nor does it mean that you should avoid type inference. Type inference in many instances can lead to code that is easier to read, maintain, understand and is even safer.\nBut sometimes you and Swift will understand each other more if you just talk to each other.\nNext time, we start learning about generics in Swift.\nIn my experience, Xcode will often fail when I click \u0026ldquo;Show Quick Help\u0026rdquo;, instead of displaying \u0026ldquo;No Quick Help\u0026rdquo;. If you can find any tips to make Quick Help more reliable, please let me know on social media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"March 16, 2024","permalink":"/blog/swift-generics/explicit-types-swift/","section":"Posts","summary":"Generics are one of the most powerful features in Swift, yet they can often feel overwhelming, even for seasoned Swift developers.","title":"Explicit and Implicit Types in Swift"},{"content":" Tech Stack # Component Tech Platforms iOS, iPadOS Architecture TCA (The Composable Architecture) UI SwiftUI Purchases RevenueCat ","date":"March 1, 2024","permalink":"/blog/projects/hawaiian-vocab/","section":"Projects","summary":" Tech Stack # Component Tech Platforms iOS, iPadOS Architecture TCA (The Composable Architecture) UI SwiftUI Purchases RevenueCat ","title":"Hawaiian Vocab"},{"content":"GitHub\nTech Stack # Component Tech Platforms iOS Architecture TCA (The Composable Architecture) Model Paradigm FSM (Finite State Machine) UI SwiftUI ","date":"October 9, 2023","permalink":"/blog/projects/tcacalc/","section":"Projects","summary":"GitHub","title":"TCACalc"},{"content":" Tip: Try the code for yourself! If you like this, please try the Swift Package that I created called PlusNightMode.\nNote: I originally posted this blog post to Medium, here.\nScreens have propagated to practically every area of our lives and while that has been tremendously beneficial in many ways, it has led¬†chronic sleep issues. To address this, Apple and the rest of the tech industry has slowly rolled out a variety of features to tackle this problem. First, there was¬†Night Shift,¬†Dark Mode, then¬†Screen Time. Now in iOS 17, Apple has introduced ‚ÄúNight Mode‚Äù, except it‚Äôs not in it‚Äôs own feature. It‚Äôs buried inside of other features (StandBy¬†on iPhone, and the¬†Wayfinder¬†watch face on Apple Watch Ultra).\nWhat is Night Mode? #When I first used StandBy, I was dramatically surprised by how effective it was. For the past decade we‚Äôve been told how light at night wreaks havoc on our circadian rhythm, and in particular blue light. Because of this, many companies added a Night Shift mode that would filter out blue light. While Night Shift does help, and I still have it active on all my devices, it really has been marginally helpful in my life. The truth is that¬†any light at night is detrimental to our sleep. Blue light may be worse than other colors, but even a small amount of any light is bad.\nAnd so, I was quite skeptical when I first tried iOS 17‚Äôs new Night Mode inside of StandBy. Would it be marginally helpful, like Night Shift? Actually, no. When I placed my iPhone, horizontally, onto my MagSafe charger, it automatically detected that the room was dark and switched the screen into Night Mode. Meanwhile my body still felt sleepy. The screen appeared to have a dramatically smaller effect on my awakeness.\nIn Night Mode, every single pixel is either pitch black, or a shade of red. And remember, on OLED screens, a pitch black pixel is emitting no light whatsoever. This means that overall the screen is much darker and virtually all blue light is filtered out. In other words, Night Mode is a much more aggressive combination of Dark Mode and Night Shift.\nThe fact that Apple has rolled out this feature onto two products signals to me that over time Apple will ship this feature across the entire system. I‚Äôm looking forward to the day when our devices automatically switch to Night Mode when it‚Äôs time to¬†wind down¬†and our screens are far less detrimental to our health.\nBut we don‚Äôt have to wait for that future. Most of the seeds of that future are already built into SwiftUI, and we can fairly easily implement Night Mode inside of our own apps.\nImplementing Night Mode #Dark Mode is built into SwiftUI, so every SwiftUI View supports dark mode by default. So the easiest first step is to simply turn on Dark Mode inside of our SwiftUI Views using¬†preferredColorScheme(.dark).\nstruct NightModeView: View { var body: some View { NavigationStack { List { Image(.blindingWhite) .resizable() .frame(maxWidth: .infinity) .aspectRatio(1.0, contentMode: .fill) Text(\u0026#34;This is a text view\u0026#34;) Text(\u0026#34;Blue\u0026#34;).foregroundStyle(.blue) Text(\u0026#34;Green\u0026#34;).foregroundStyle(.green) Text(\u0026#34;Yellow\u0026#34;).foregroundStyle(.yellow) } .navigationTitle(\u0026#34;Hello World!\u0026#34;) } .preferredColorScheme(.dark) } } preferredColorScheme(_:)¬†essentially ignores the user‚Äôs Dark Mode state, and sets the¬†ColorScheme¬†directly on the View. What‚Äôs even better, it changes the¬†\\.colorScheme¬†environment value, which means that every child View will automatically inherit and observe that colorScheme.\nNow the screen is dark but there is still a lot of blue light. (Remember that colors like white and green still contain blue.) Also any Image is unaffected by the colorScheme. (I remember watching The Fellowship of the Ring for the first time in theaters, and being blinded when Frodo first meets Galadriel üòµ because the screen was so bright).\nImplementing a red filter #A naive approach might look like overlaying a red view with 50% opacity like so:\nstruct NightModeView: View { var body: some View { NavigationStack { List { Image(.blindingWhite) .resizable() .frame(maxWidth: .infinity) .aspectRatio(1.0, contentMode: .fill) Text(\u0026#34;This is a text view\u0026#34;) Text(\u0026#34;Blue\u0026#34;).foregroundStyle(.blue) Text(\u0026#34;Green\u0026#34;).foregroundStyle(.green) Text(\u0026#34;Yellow\u0026#34;).foregroundStyle(.yellow) } .navigationTitle(\u0026#34;Hello World!\u0026#34;) } .preferredColorScheme(.dark) .overlay { Color.red.opacity(0.5) .ignoresSafeArea() } } } However, while that does indeed turn the screen red (and thereby filter out most of the blue), it actually makes the screen brighter. Before the background was pitch black but now it‚Äôs red.\nSo we want to keep all black pixels black, but we want all the other colors to be a shade of red. ü§î Thankfully, digital photo editors solved this problem long ago, and SwiftUI has added many of the same functions that we‚Äôve been using in Photoshop for decades. I played around with a few of them and here is my best result so far:\nstruct NightModeView: View { var body: some View { NavigationStack { List { Image(.blindingWhite) .resizable() .frame(maxWidth: .infinity) .aspectRatio(1.0, contentMode: .fill) Text(\u0026#34;This is a text view\u0026#34;) Text(\u0026#34;Blue\u0026#34;).foregroundStyle(.blue) Text(\u0026#34;Green\u0026#34;).foregroundStyle(.green) Text(\u0026#34;Yellow\u0026#34;).foregroundStyle(.yellow) NavigationLink(\u0026#34;Go to second page\u0026#34;, value: \u0026#34;second page\u0026#34;) } .navigationTitle(\u0026#34;Hello World!\u0026#34;) .navigationDestination(for: String.self) { string in Text(string) } } .monochromed(color: .red) } } extension View { func monochromed(color: Color, colorScheme: ColorScheme = .dark) -\u0026gt; some View { let filter: some View = color .blendMode(.color) .opacity(0.5) .allowsHitTesting(false) return self .preferredColorScheme(colorScheme) .tint(color) .overlay { filter .ignoresSafeArea() } .colorMultiply(color) } } Wow, I feel like I turned my iPhone into a¬†VirtualBoy!\nLet‚Äôs explain how we did this. I made a new function called¬†monochromed(color: colorScheme:)¬†so in the future we can add Night Mode with a single line of code. The¬†color:¬†parameter is what color we want the whole screen to be. In our case, we‚Äôll use¬†.red¬†. Next, the¬†colorScheme:¬†can be light or dark but it defaults to dark.\nmonochromed(color:)¬†essentially does the same thing as our earlier example. It overlays a red View. However, the View that it overlays is slightly more sophisticated. First we start off with the same red view. Then we add¬†.blendMode(.color). Like many functions we‚Äôll be using here,¬†blend mode¬†should be fairly familiar to anyone who‚Äôs worked in photo editors. Trailing Closure has a fantastic¬†cheat sheet¬†about all the available blend modes in SwiftUI. In it we can see:\n.color\nThe Color blend mode preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\nü§∑üèº‚Äç‚ôÇÔ∏è i.e. It blends the colors together.\nopacity(0.5)¬†I played around with the opacity of this filter a bit and so far 50% was my favorite. 100% made everything too bright red, and 25% didn‚Äôt filter out other colors enough.\n.colorMultiply(color)¬†: This¬†SwiftUI function¬†adds a¬†color multiplication effect. This is in fact another blend mode that we can find in most photo editors. Wikipedia states:\nMultiply blend mode takes the RGB channel values from 0 to 1 of each pixel in the top layer and multiples them with the values for the corresponding pixel from the bottom layer. Wherever either layer was brighter than black, the composite is darker; since each value is less than 1, their product will be less than each initial value that was greater than zero.\nAgain ü§∑üèº‚Äç‚ôÇÔ∏è. But my very limited understanding is that this is what enables the black pixels to remain black. A black pixel has an RGB channel value of 0. So anything multiplied by 0 is 0, i.e. black pixels stay black. Notice that¬†.colorMultiply¬†is applied to the View itself and not the overlayed filter View. Next let‚Äôs look at a few quality of life improvements.\n.allowsHitTesting(false)¬†: If we didn‚Äôt have this then no touch events would reach our Views at all, since we‚Äôd be touching the red filter view and not the views underneath.\n.tint(color)¬†: We are essentially filtering out every color except for red. So why not change the tint of our app to match, so that it doesn‚Äôt get filtered out. This is extra important because the default tint color in SwiftUI is blue. Remember, the entire point of a Night Mode is to filter out blue light, so by monochroming to red, we are effectively filtering out blue. Anything that is not red is going to be harder to see, and the further it is from red, the less visible it will be, meaning that blue is practically invisible now. The entire point of¬†tint in SwiftUI¬†is to highlight certain elements to the user. So while using our filter, it makes sense to match our tint to the color of the filter so that our tinted elements remain highly visible.\nRoom for improvement #As much as I love Night Mode, and I impatiently wait for Apple to roll out Night Mode everywhere, it makes sense that Apple has only rolled out this feature to two small niche areas.¬†Design systems are hard. As we can see there are many edge cases. We‚Äôve covered many edge cases so far. For example, this solution now effectively turns every pixel in every SwiftUI View into either black or a shade of red. However, it creates new problems. Anything blue is effectively invisible, rendering many apps unusable. In addition, many Views will lose contrast and legibility. For example, look at the green Text. It‚Äôs still visible, but it is much harder to read. These are all design problems that we will work on as an industry over the next several years.\nI expect that the industry will slowly have a transition to supporting Night Mode everywhere, just as we are still transitioning to supporting Dark Mode everywhere. Dark Mode used to be extremely difficult to adopt in UIKit, but with SwiftUI, Apple made it trivial. Now Dark Mode is not just on Apple and Android apps, but it‚Äôs almost everywhere, even in our operating systems and many websites. I hope that one day soon, Apple sherlocks this implementation and simply makes it a baked in part of the system. I also hope that over time Night Mode will be adopted everywhere. But we must recognize that that is a gargantuan task. It will require designers and engineers everywhere to change their workflow, and the transition will take years.\nIs all of that work worth it? Absolutely, yes! Screens are here to stay, whether we like it or not. Yet we are currently in the middle of a¬†sleep deprivation crisis. For more information on how important sleep is, and how disasterous light from devices can be, I highly recommond¬†this podcast by Andrew Huberman. The point is that users shouldn‚Äôt have to choose between your wonderful app and their sleep. And we shouldn‚Äôt be making software that negatively impacts our user‚Äôs health. Period.\nThankfully, there is a solution, and it‚Äôs not that hard to implement. It‚Äôs not perfect, but it‚Äôs a start. Do your users a favor and adopt the option for Night Mode. And do yourself a favor. Adopt Night Mode. I wouldn‚Äôt be surprised if Night Mode becomes very popular in the near future, just like Dark Mode. If so, then many users will crave, no, demand Night Mode. Night Mode could not only differentiate you from other apps, it could actually be the thing preventing users from choosing your app. Let me be clear. I don‚Äôt want to give you false hype. Night Mode is not a silver bullet, just as Night Shift and Dark Mode were not silver bullets. But soon Night Mode will be another important tool in our tool belt toward building healthy sleep. You‚Äôd be a fool not to adopt it.\nConclusion #In this tutorial we learned how incredibly harmful device lights can be to your sleep and therefore health. We saw how Apple made a powerful filter called Night Mode that we too can adopt with a few lines of code.\nI‚Äôve created a¬†public gist¬†where you can try out this implementation for yourself. If you like it, please ‚≠ê Star it.\nNext time, we will learn how to make our Night Mode more dynamic so that the user can turn it on and off. We will also learn how to tell child views that they are in Night Mode so that they can present themselves more legibly.\n","date":"September 14, 2023","permalink":"/blog/posts/how-to-add-night-mode-to-swiftui/","section":"Posts","summary":"Tip: Try the code for yourself!","title":"How to add Apple‚Äôs ‚ÄúNight Mode‚Äù to your SwiftUI Views"},{"content":"","date":null,"permalink":"/blog/topics/swiftui/","section":"Topics","summary":"","title":"SwiftUI"},{"content":" Note: I originally posted this blog post to Medium, here.\nJavaScript‚Äôs¬†for...of¬†loop is a powerful construct for iterating over elements in an¬†iterable, such as arrays, strings, or¬†other iterable objects. However, unlike the traditional¬†C-style for loop,¬†the¬†**for...of**¬†loop doesn\u0026rsquo;t provide a built-in index. But fear not! In this blog post, we\u0026rsquo;ll learn how to use the¬†for...of¬†loop with an index.\nThe Traditional¬†for...of¬†Loop #Before diving into adding an index, let‚Äôs quickly review how the standard¬†for...of¬†loop works:\nconst nums = [10, 20, 30, 40, 50]; for (const num of nums) { console.log(num); } This loop will iterate through¬†==nums==¬†and print each element to the console. However, if you need to keep track of the index as well, you can modify the loop‚Ä¶\nAdding an Index to the¬†for...of¬†Loop #To add an index to the¬†for...of¬†loop, you can use the¬†entries()¬†method of an array, which returns an iterable containing index-value pairs. Here\u0026rsquo;s how you can do it:\nconst nums = [10, 20, 30, 40, 50]; for (const [index, num] of nums.entries()) { console.log(`Index: ${index}, Value: ${num}`); } In this modified loop, we use the¬†entries()¬†method to get an iterable of index-value pairs, and then we¬†destructure¬†each pair into¬†index¬†and¬†num. Now, you have access to both the index and the value during each iteration.\nOutput #Index: 0, Value: 10 Index: 1, Value: 20 Index: 2, Value: 30 Index: 3, Value: 40 Index: 4, Value: 50 With this approach, you can easily work with both the elements and their respective indices when using the¬†for...of¬†loop.\nConsiderations #Be aware that the¬†entries()¬†method used above loops through the array once with an efficiency of¬†O(n). So if you have a very large array, you will notice a performance cost. As with everything else, there are tradeoffs. Personally, I think readability and maintainability are worth a negligible performance cost. For example, this style of for loop makes it all but impossible to commit the subtle¬†Off-by-one error. The best code is the code you never have to write in the first place, and if you eliminate the need to check for an off-by-one error in the first place, then I think that‚Äôs a great tradeoff.\nNevertheless, if you‚Äôre dealing with strict performance constraints, weak hardware, or massive datasets, then you should certainly consider using the C-style for loop.\nConclusion #JavaScript‚Äôs¬†for...of¬†loop is a versatile way to iterate over iterable objects. By leveraging the¬†entries()¬†method, you can easily include an index alongside the values in your loops. This can be especially useful when you need to perform operations that require knowledge of the element\u0026rsquo;s position within the iterable. Happy coding!\n","date":"September 7, 2023","permalink":"/blog/posts/js-loop-with-index/","section":"Posts","summary":"Note: I originally posted this blog post to Medium, here.","title":"How to use a JS for...of loop with an index"},{"content":"","date":null,"permalink":"/blog/topics/javascript/","section":"Topics","summary":"","title":"JavaScript"},{"content":"Available at # GitHub Swift Package Index Tech Stack # Component Tech Platforms iOS, iPadOS Architecture TCA (The Composable Architecture) UI SwiftUI Purchases RevenueCat ","date":"August 1, 2023","permalink":"/blog/projects/plusnightmode/","section":"Projects","summary":"Available at # GitHub Swift Package Index Tech Stack # Component Tech Platforms iOS, iPadOS Architecture TCA (The Composable Architecture) UI SwiftUI Purchases RevenueCat ","title":"PlusNightMode"},{"content":" NOTE: I originally posted this blog post to Medium, here.\nSwiftUI is a complete paradigm shift in how we write apps for Apple platforms. It‚Äôs functional and declarative rather than object-oriented and imperative. And there is no need for ViewControllers anymore! While all of this means that we can write code that is more readable, testable, and reusable, it also means that we don‚Äôt have decades of tried and true architecture patterns to draw from.\nThankfully SwiftUI makes it easy to break apart your code into reusable components. Today, I‚Äôd like to explore all the ways I‚Äôve found to organize SwiftUI code. (Actually, I‚Äôm not so much talking about the architecture. Instead, right now I‚Äôd like to explore the different techniques we can use to split SwiftUI code into smaller, more manageable piece.)\nA Bad Example #Throughout this blog post, I‚Äôll be looking at an example of ‚Äúbad‚Äù SwiftUI code. This code is bad, not because it‚Äôs non-performant. It‚Äôs actually just as performant as all of the later, examples. Neither is it bad because it‚Äôs verbose. It‚Äôs actually quite short. Only 27 lines of code. No, this code is bad because it‚Äôs really confusing to read:\nstruct NestedListExample: View { @State var notificationsOn: Bool = false @State var soundOn: Bool = true @State var hapticsOn: Bool = true var body: some View { NavigationView { List { NavigationLink(\u0026#34;Settings\u0026#34;, destination: List { NavigationLink(\u0026#34;Notifications\u0026#34;, destination: List { Toggle(\u0026#34;Notifications: \u0026#34;, isOn: $notificationsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) ) NavigationLink(\u0026#34;Sound and Haptics\u0026#34;, destination: List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) ) }.navigationTitle(\u0026#34;Settings\u0026#34;) ) } .navigationTitle(\u0026#34;1st List\u0026#34;) } } } This monstrosity, is technically valid SwiftUI code, but I wouldn‚Äôt recommend using it. It‚Äôs three layers deep of nested¬†Lists. Let‚Äôs look at how we can split it into smaller pieces that are easier to read, reason, test, reuse and maintain.\nYour SwiftUI App is just one giant View #First, let‚Äôs look at that these two templates that we‚Äôve see a million times:\n// Example App.swift import SwiftUI @main struct ExampleApp: App { var body: some Scene { WindowGroup { ContentView() } } }// ContentView.swift import SwiftUI struct ContentView: View { var body: some View { Text(\u0026#34;Hello, world!\u0026#34;) .padding() } } Pardon me for stating the obvious,¬†ExampleAppcalls¬†ContentView()which means that if you wanted to you could condense¬†ExampleApp¬†and¬†ContentViewinto one file like this:\n// ExampleApp.swift import SwiftUI @main struct ExampleApp: App { var body: some Scene { WindowGroup { Text(\u0026#34;Hello, world!\u0026#34;) .padding() } } } A SwiftUI app is really just an¬†App¬†holding a¬†Scene, holding a¬†View, holding a¬†View, holding a¬†View, etc. In fact, you could run your entire app from one file.¬†Obviously, I wouldn‚Äôt recommend this.¬†But just knowing that we can shows us the first way to split SwiftUI code.\nSeven Ways To Split Your SwiftUI Code #Method #1: Extract To Separate Struct #If we look at my combined¬†ExampleApp¬†implementation, and Apple‚Äôs template of¬†ExampleApp¬†and¬†ContentView¬†we can see that Apple extracted¬†Text(\u0026quot;Hello, world!\u0026quot;).padding()¬†out into its own¬†View¬†struct called¬†ContentView. We can follow this pattern for any of our views.\nLet‚Äôs look at how we could use this in our monster List example from earlier:\n// NestedListExample.swift struct NestedListExample: View { @State var notificationsOn: Bool = false @State var soundOn: Bool = true @State var hapticsOn: Bool = true var body: some View { NavigationView { List { NavigationLink(\u0026#34;Settings\u0026#34;, destination: SettingsView(notificationsOn: $notificationsOn, soundOn: $soundOn, hapticsOn: $hapticsOn) ) } .navigationTitle(\u0026#34;1st List\u0026#34;) } } } // NotificationsView.swift struct NotificationsView: View { @Binding var notificationsOn: Bool var body: some View { List { Toggle(\u0026#34;Notifications: \u0026#34;, isOn: $notificationsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) } } // SettingsView.swift struct SettingsView: View { @Binding var notificationsOn: Bool @Binding var soundOn: Bool @Binding var hapticsOn: Bool var body: some View { List { NavigationLink(\u0026#34;Notifications\u0026#34;, destination: NotificationsView(notificationsOn: $notificationsOn) ) NavigationLink(\u0026#34;Sound and Haptics\u0026#34;, destination: SoundAndHapticsView(soundOn: $soundOn, hapticsOn: $hapticsOn) ) }.navigationTitle(\u0026#34;Settings\u0026#34;) } } // SoundAndHapticsView.swift struct SoundAndHapticsView: View { @Binding var soundOn: Bool @Binding var hapticsOn: Bool var body: some View { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) } } üôÄ Ay caramba! Now the code is even longer and more confusing! Well actually no. This new code is far more readable. There‚Äôs no longer a pyramid of doom.\nAlso, it‚Äôs easier to maintain and edit. What if your designer designer said to you ‚ÄúActually, could you please move the notifications onto the sound page?‚Äù Now it is much easier to simply paste¬†NotificationsView()¬†wherever you want to use it.\nYes this new code is quite a bit longer (54 lines as opposed to just 27 lines before) but shorter is not always better, especially if it means making your code less readable.\nStill, this approach does have a drawback. Every nested struct loses access to its parent‚Äôs properties, which means that we have to pass in a binding into each struct. While this method is great at separating our Views into smaller pieces, some times it adds more friction than it‚Äôs worth. Let‚Äôs look at some other methods.\nQuick Tip:¬†Let Xcode do at least some of the work for you. If you ‚åò-Click any subview and choose¬†Extract subview¬†then Xcode will create the separate struct for you! Wow! But bear in mind it won‚Äôt create any properties that you will need. At least it can do a lot of the busywork for you.\nMethod #2: Extract To Local Computed Property #Looking more at all over our SwiftUI code we can see that every single View contains¬†var body: some View. Don‚Äôt let SwiftUI‚Äôs ‚Äúmagic‚Äù fool you. It‚Äôs not magic at all. This is just a plain old computed property which is built into the Swift language. So:\nvar body: some View { Text(\u0026#34;Hello World!\u0026#34;) } Is really just short for: var body: some View { get { return Text(\u0026#34;Hello World!\u0026#34;) } } We can use this exact same approach anywhere in our code. For example like this:\nstruct NestedListExample: View { @State var notificationsOn: Bool = false @State var soundOn: Bool = true @State var hapticsOn: Bool = true var body: some View { NavigationView { List { NavigationLink(\u0026#34;Settings\u0026#34;, destination: settings ) } .navigationTitle(\u0026#34;1st List\u0026#34;) } } var settings: some View { List { NavigationLink(\u0026#34;Notifications\u0026#34;, destination: notifications ) NavigationLink(\u0026#34;Sound and Haptics\u0026#34;, destination: soundAndHaptics ) }.navigationTitle(\u0026#34;Settings\u0026#34;) } var notifications: some View { List { Toggle(\u0026#34;Notifications: \u0026#34;, isOn: $notificationsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) } var soundAndHaptics: some View { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) } } Once again, our code is more readable, but notice that this time we didn‚Äôt have to pass any¬†Bindings. Why? Because everything is inside the same struct. It can just read the same properties that are already there.\nMethod #3: Extract To A Function #Remember before that we extracted our subview out into a computed property? Well what is a computed property? Really, it‚Äôs just a function. So:\nvar soundAndHaptics: some View { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) } can be rewritten as:\nfunc soundAndHaptics() -\u0026gt; some View { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) } It‚Äôs basically exactly the same thing. In fact, the compiler thinks it‚Äôs the exact same thing. If you include both of these definitions, then the compiler will say¬†Invalid redeclaration of 'soundAndHaptics()'which means that a computed property is really just another function under the hood.\nHowever, there is a difference at the call site. If you declare it as a computed variable then you will call it with¬†soundAndHaptics. But if you declare it as a func then you will call it with¬†soundAndHaptics(). The extra¬†()¬†tells Swift that we are running that function inline and immediately using the returned View.\nStill, I probably wouldn‚Äôt use this extraction method very often. Why? Semantics. When I think of a func, I think of verbs. When I think of a var I think of nouns. In my brain,¬†Views are nouns.\n==However, one difference between a func and a computed property is that computed properties can‚Äôt accept parameters. But a func can. So we could write something like this:==\nfunc soundAndHaptics(isPremiumUser: Bool) -\u0026gt; some View { let anyView: AnyView if isPremiumUser { anyView = List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) as! AnyView } else { anyView = List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) // Haptics are not included for non premium users }.navigationTitle(\u0026#34;Notifications\u0026#34;) as! AnyView } return anyView } Now that we‚Äôre using a func instead of a computed property, we can add more logic to dynamically change the View as necessary. (There are better ways to achieve that variability, but it‚Äôs nice to know that this is another tool in the toolbox.)\nMethod #4: Extract To an @ViewBuilder Function #If you‚Äôve been paying attention then that last method must have left a bad taste in your mouth.¬†Why is he using AnyView?¬†Anytime, you see AnyView, it‚Äôs a sign that there‚Äôs probably a better way to do what you‚Äôre trying to do. And oftentimes that better way is¬†@ViewBuilder. Let‚Äôs look at how we can use¬†@ViewBuilder¬†to clean up our last example.\n@ViewBuilder func soundAndHaptics(isPremiumUser: Bool) -\u0026gt; some View { if isPremiumUser { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) } else { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) // Haptics are not included for non premium users }.navigationTitle(\u0026#34;Notifications\u0026#34;) } } Now, Swift no longer complains. We don‚Äôt have to type erase with AnyView anymore. John Sundell does a great job of explaining this here:¬†Avoiding SwiftUI‚Äôs AnyView\nThis method is used extensively in Apple‚Äôs own SwiftUI framework. Take a look at the declaration of VStack. It‚Äôs initializer accepts a parameter called¬†content¬†that looks like this:¬†@ViewBuilder content: () -\u0026gt; ContentThis is just a function, just like the one we just made. And as we can see in the declaration of VStack here:\n@frozen struct VStack\u0026lt;Content\u0026gt; where Content : View\nContent is just a generic name for any type that conforms to View.\nSo while @ViewBuilder functions might be somewhat useful when we want to separate a subview, they are way more useful when we want to accept a @ViewBuilder from someone else.\nMethod #5: Extract To an @ViewBuilder Computed Property #It‚Äôs worth mentioning that computed properties can also be wrapped in a¬†@ViewBuilder.¬†@ViewBuilder¬†is just a¬†@resultBuilder.¬†@ResultBuilder¬†‚Äôs can be applied to functions, and since computed properties are basically functions under the hood, that means you can use¬†@ViewBuilder¬†on a computed property!\nSo we can rewrite:\n// func version @ViewBuilder func soundAndHaptics(isPremiumUser: Bool) -\u0026gt; some View { if isPremiumUser { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) as! AnyView } else { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) // Haptics are not included for non premium users }.navigationTitle(\u0026#34;Notifications\u0026#34;) as! AnyView } } into:\n// computed variable version @ViewBuilder var soundAndHaptics: some View { if isPremiumUser { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) Toggle(\u0026#34;Haptics: \u0026#34;, isOn: $hapticsOn) }.navigationTitle(\u0026#34;Notifications\u0026#34;) } else { List { Toggle(\u0026#34;Sound: \u0026#34;, isOn: $soundOn) // Haptics are not included for non premium users }.navigationTitle(\u0026#34;Notifications\u0026#34;) } } Now our computed variable can use any logic that we need just like the function version. Plus, we don‚Äôt even need to pass in a parameter, as long as¬†isPremiumUser¬†is in the same struct.\nMethod #6: Extract To static func or var #Of course, if a View can be a var or a func, then that also means that it can be a static var or func. Something like this:\n// static var @ViewBuilder static var exampleTableCell: some View { List { Text(\u0026#34;Hello\u0026#34;) } } // static func @ViewBuilder static func exampleToggle(_ binding: Binding\u0026lt;Bool\u0026gt;) -\u0026gt; some View { List { Toggle(\u0026#34;Toggle\u0026#34;, isOn: binding) } } This method can be really helpful for adding in example View‚Äôs when you are still prototyping. Just remember that any static var or func, won‚Äôt be able to use any of your instance variables like our¬†isPremiumUser¬†variable from earlier.\nMethod #7: Extract To A Style #What if I want to create a View that has some customization, but I still want to keep some of the uniformity of the built-in Views? For example, what if I have a Button that has some custom styling. Here‚Äôs a simple example:\nstruct RedCircleButton: View { let string: String let action: () -\u0026gt; Void var body: some View { Button(string, action: action) .clipShape(Circle()) .foregroundColor(.red) } } Now my button is very reusable. But I‚Äôve sacrificed customizability. What if I want to use a View as my label instead of a String? Thankfully, SwiftUI has a solution to this as well: Styles. Many SwiftUI views come Style types. These let you call a normal built-in type, and place all your custom styling in your ‚ÄúStyle‚Äù Type. For example:\nstruct RedCircleButtonStyle: ButtonStyle { public func makeBody(configuration: RedCircleButtonStyle.Configuration) -\u0026gt; some View { RedCircleButton(configuration: configuration) } struct RedCircleButton: View { let configuration: RedCircleButtonStyle.Configuration var body: some View { configuration.label .foregroundColor(.red) .clipShape(Circle()) } } } And to use it we just write:\nButton(\u0026#34;Some String\u0026#34;) { print(\u0026#34;Do something\u0026#34;)} .buttonStyle(RedCircleButtonStyle()) SwiftUI comes with many style protocols including¬†ButtonStyle,¬†ListStyle,¬†PickerStyle¬†, you get the picture.\nThe Right Method for the Job #Those are all the methods of splitting SwiftUI code that I‚Äôve found. Have you found anymore that I should add?\nWith so many options for splitting code. How do we know which to use when? First, don‚Äôt overthink it. Thankfully, SwiftUI makes it much easier to split and refactor code than UIKit. We don‚Äôt have massive ViewControllers with complex side effects to think about (but it is our responsibility, to separate View and Model logic). Here are my suggestions of when to use each of these methods:\nMethod #1: Extract To Separate Struct: Use when you want something, custom and reusable. Method #2: Extract To Local Computed Property:¬†Use when you want something private and internal. Method #3: Extract To A Function:¬†Also works for something private and internal, but personally I would prefer a computed property for that use case. Method #4: Extract To an @ViewBuilder Function: Great for when you want to enable another View to pass you a View. Method #5: Extract To an @ViewBuilder Computed Property:¬†Great for when you need something internal and private, that also has some internal logic, especially if you need to erase Type. Method #6: Extract To static func or var:¬†Great for when you want mock example Views. Method #7: Extract To A Style: Great for when you only want to extract custom styling but not custom logic. I‚Äôm sure there are many use cases that are not listed here but I hope it‚Äôs a good starting point. Now get out there and start organizing your SwiftUI code!\n","date":"May 6, 2021","permalink":"/blog/posts/7-ways-to-organize-swiftui-code/","section":"Posts","summary":"NOTE: I originally posted this blog post to Medium, here.","title":"7 Ways to Organize SwiftUI Code"},{"content":"","date":"January 1, 0001","permalink":"/blog/about/","section":"","summary":"","title":""},{"content":"","date":"January 1, 0001","permalink":"/blog/blog/","section":"","summary":"","title":""},{"content":" Job Copilot is currently available for pre-release testing.\nTech Stack # Component Tech Platforms iOS, iPadOS Architecture TCA (The Composable Architecture) UI SwiftUI LLM Gemini ","date":"January 1, 0001","permalink":"/blog/projects/job-copilot/","section":"Projects","summary":"Job Copilot is currently available for pre-release testing.","title":"Job Copilot"}]